/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package topology

import (
	"context"
	"fmt"

	"github.com/pkg/errors"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apiserver/pkg/storage/names"
	"k8s.io/utils/pointer"
	clusterv1 "sigs.k8s.io/cluster-api/api/v1alpha4"
	"sigs.k8s.io/cluster-api/controllers/external"
)

// computeDesiredState computes the desired state of the cluster topology.
// NOTE: We are assuming all the required objects are provided as input; also, in case of any error,
// the entire compute operation operation will fail. This might be improved in the future if support for reconciling
// subset of a topology will be implemented.
func (r *ClusterReconciler) computeDesiredState(_ context.Context, class *clusterTopologyClass, current *clusterTopologyState) (*clusterTopologyState, error) {
	var err error
	desiredState := &clusterTopologyState{}

	// Compute the desired state of the InfrastructureCluster object.
	if desiredState.infrastructureCluster, err = computeInfrastructureCluster(class, current); err != nil {
		return nil, err
	}

	// If the ControlPlane object requires it, compute the InfrastructureMachineTemplate for the ControlPlane.
	if class.clusterClass.Spec.ControlPlane.MachineInfrastructure != nil {
		if desiredState.controlPlane.infrastructureMachineTemplate, err = computeControlPlaneInfrastructureMachineTemplate(class, current); err != nil {
			return nil, err
		}
	}

	// Compute the desired state of the ControlPlane object, eventually adding a reference to the
	// InfrastructureMachineTemplate generated by the previous step.
	if desiredState.controlPlane.object, err = computeControlPlane(class, current, desiredState.controlPlane.infrastructureMachineTemplate); err != nil {
		return nil, err
	}

	// Compute the desired state for the Cluster object adding a reference to the
	// InfrastructureCluster and the ControlPlane objects generated by the previous step.
	desiredState.cluster = computeCluster(current, desiredState.infrastructureCluster, desiredState.controlPlane.object)

	// Compute the desired state of the MachineDeployment objects for the worker nodes.
	if current.cluster.Spec.Topology.Workers == nil || len(current.cluster.Spec.Topology.Workers.MachineDeployments) == 0 {
		return desiredState, nil
	}

	desiredState.machineDeployments = map[string]*machineDeploymentTopologyState{}
	for _, mdTopology := range current.cluster.Spec.Topology.Workers.MachineDeployments {
		desiredMachineDeployment, err := computeMachineDeployment(class, current, mdTopology)
		if err != nil {
			return nil, err
		}
		desiredState.machineDeployments[mdTopology.Name] = desiredMachineDeployment
	}
	return desiredState, nil
}

// computeInfrastructureCluster computes the desired state for the InfrastructureCluster object starting from the
// corresponding template defined in ClusterClass.
func computeInfrastructureCluster(class *clusterTopologyClass, current *clusterTopologyState) (*unstructured.Unstructured, error) {
	infrastructureCluster, err := templateToObject(templateToInput{
		template:              class.infrastructureClusterTemplate,
		templateClonedFromRef: class.clusterClass.Spec.Infrastructure.Ref,
		cluster:               current.cluster,
		namePrefix:            fmt.Sprintf("%s-", current.cluster.Name),
		currentObjectRef:      current.cluster.Spec.InfrastructureRef,
	})
	if err != nil {
		return nil, errors.Wrapf(err, "failed to generate the InfrastructureCluster object from the %s", class.infrastructureClusterTemplate.GetKind())
	}
	return infrastructureCluster, nil
}

// computeControlPlaneInfrastructureMachineTemplate computes the desired state for InfrastructureMachineTemplate
// that should be referenced by the ControlPlane object.
func computeControlPlaneInfrastructureMachineTemplate(class *clusterTopologyClass, current *clusterTopologyState) (*unstructured.Unstructured, error) {
	var currentInfrastructureMachineTemplate *corev1.ObjectReference
	if current.controlPlane != nil && current.controlPlane.object != nil {
		var err error
		if currentInfrastructureMachineTemplate, err = getNestedRef(current.controlPlane.object, "spec", "machineTemplate", "infrastructureRef"); err != nil {
			return nil, errors.Wrap(err, "failed to get spec.machineTemplate.infrastructureRef for the current ControlPlane object")
		}
	}

	controlPlaneInfrastructureMachineTemplate := templateToTemplate(templateToInput{
		template:              class.controlPlane.infrastructureMachineTemplate,
		templateClonedFromRef: objToRef(class.controlPlane.infrastructureMachineTemplate),
		cluster:               current.cluster,
		namePrefix:            fmt.Sprintf("%s-controlplane-", current.cluster.Name),
		currentObjectRef:      currentInfrastructureMachineTemplate,
		labels:                mergeMap(current.cluster.Spec.Topology.ControlPlane.Metadata.Labels, class.clusterClass.Spec.ControlPlane.Metadata.Labels),
		annotations:           mergeMap(current.cluster.Spec.Topology.ControlPlane.Metadata.Annotations, class.clusterClass.Spec.ControlPlane.Metadata.Annotations),
	})
	return controlPlaneInfrastructureMachineTemplate, nil
}

// computeControlPlane computes the desired state for the ControlPlane object starting from the
// corresponding template defined in ClusterClass.
func computeControlPlane(class *clusterTopologyClass, current *clusterTopologyState, infrastructureMachineTemplate *unstructured.Unstructured) (*unstructured.Unstructured, error) {
	controlPlane, err := templateToObject(templateToInput{
		template:              class.controlPlane.template,
		templateClonedFromRef: class.clusterClass.Spec.ControlPlane.Ref,
		cluster:               current.cluster,
		namePrefix:            fmt.Sprintf("%s-", current.cluster.Name),
		currentObjectRef:      current.cluster.Spec.ControlPlaneRef,
		labels:                mergeMap(current.cluster.Spec.Topology.ControlPlane.Metadata.Labels, class.clusterClass.Spec.ControlPlane.Metadata.Labels),
		annotations:           mergeMap(current.cluster.Spec.Topology.ControlPlane.Metadata.Annotations, class.clusterClass.Spec.ControlPlane.Metadata.Annotations),
	})
	if err != nil {
		return nil, errors.Wrapf(err, "failed to generate the ControlPlane object from the %s", class.controlPlane.template.GetKind())
	}

	// If the ControlPlane object requires it, add a reference to InfrastructureMachine template to be used for the control plane machines.
	// NOTE: Once set for the first time, the reference name is not expected to changed in this step
	// (instead it could change later during the reconciliation if template rotation is triggered)
	if class.clusterClass.Spec.ControlPlane.MachineInfrastructure != nil {
		if err := setNestedRef(controlPlane, infrastructureMachineTemplate, "spec", "machineTemplate", "infrastructureRef"); err != nil {
			return nil, errors.Wrap(err, "failed to spec.machineTemplate.infrastructureRef in the ControlPlane object")
		}
	}

	// If it is required to manage the number of replicas for the control plane, set the corresponding field.
	// NOTE: If the Topology.controlPlane.replicas value is nil, it is assumed that the control plane controller
	// does not implement support for this field and the ControlPlane object is generated without the number of Replicas.
	if current.cluster.Spec.Topology.ControlPlane.Replicas != nil {
		if err := unstructured.SetNestedField(controlPlane.UnstructuredContent(), int64(*current.cluster.Spec.Topology.ControlPlane.Replicas), "spec", "replicas"); err != nil {
			return nil, errors.Wrap(err, "failed to set spec.replicas in the ControlPlane object")
		}
	}

	// Sets the desired Kubernetes version for the control plane.
	// TODO: improve this logic by adding support for version upgrade component by component
	if err := unstructured.SetNestedField(controlPlane.UnstructuredContent(), current.cluster.Spec.Topology.Version, "spec", "version"); err != nil {
		return nil, errors.Wrap(err, "failed to set spec.version in the ControlPlane object")
	}

	return controlPlane, nil
}

// computeCluster computes the desired state for the Cluster object.
// NOTE: Some fields of the Clusterâ€™s fields contribute to defining how a Cluster should look like (e.g. Cluster.Spec.Topology),
// while some other fields should be managed as part of the actual Cluster (e.g. Cluster.Spec.ControlPlaneRef); in this func
// we are concerned only about the latest group of fields.
func computeCluster(current *clusterTopologyState, infrastructureCluster, controlPlane *unstructured.Unstructured) *clusterv1.Cluster {
	cluster := &clusterv1.Cluster{}
	current.cluster.DeepCopyInto(cluster)

	// Enforce the topology labels.
	// NOTE: The cluster label is added at creation time so this object could be read by the ClusterTopology
	// controller immediately after creation, even before other controllers are going to add the label (if missing).
	if cluster.Labels == nil {
		cluster.Labels = map[string]string{}
	}
	cluster.Labels[clusterv1.ClusterLabelName] = cluster.Name
	cluster.Labels[clusterv1.ClusterTopologyLabelName] = ""

	// Set the references to the infrastructureCluster and controlPlane objects.
	// NOTE: Once set for the first time, the references are not expected to change.
	cluster.Spec.InfrastructureRef = objToRef(infrastructureCluster)
	cluster.Spec.ControlPlaneRef = objToRef(controlPlane)

	return cluster
}

// computeMachineDeployment computes the desired state for a MachineDeploymentTopology.
// The generated machineDeployment object is calculated using the values from the machineDeploymentTopology and
// the machineDeployment class.
func computeMachineDeployment(class *clusterTopologyClass, current *clusterTopologyState, machineDeploymentTopology clusterv1.MachineDeploymentTopology) (*machineDeploymentTopologyState, error) {
	desiredMachineDeployment := &machineDeploymentTopologyState{}

	className := machineDeploymentTopology.Class
	machineDeploymentClass, ok := class.machineDeployments[className]
	if !ok {
		return nil, errors.Errorf("MachineDeployment class %s not found in ClusterClass %s", className, class.clusterClass.Name)
	}

	currentMachineDeployment := current.machineDeployments[machineDeploymentTopology.Name]
	var currentBootstrapTemplateRef *corev1.ObjectReference
	if currentMachineDeployment != nil && currentMachineDeployment.bootstrapTemplate != nil {
		currentBootstrapTemplateRef = currentMachineDeployment.object.Spec.Template.Spec.Bootstrap.ConfigRef
	}
	desiredMachineDeployment.bootstrapTemplate = templateToTemplate(templateToInput{
		template:              machineDeploymentClass.bootstrapTemplate,
		templateClonedFromRef: objToRef(machineDeploymentClass.bootstrapTemplate),
		cluster:               current.cluster,
		namePrefix:            bootstrapTemplateNamePrefix(current.cluster.Name, machineDeploymentTopology.Name),
		currentObjectRef:      currentBootstrapTemplateRef,
		labels:                mergeMap(machineDeploymentTopology.Metadata.Labels, machineDeploymentClass.metadata.Labels),
		annotations:           mergeMap(machineDeploymentTopology.Metadata.Annotations, machineDeploymentClass.metadata.Annotations),
	})

	var currentInfraMachineTemplateRef *corev1.ObjectReference
	if currentMachineDeployment != nil && currentMachineDeployment.infrastructureMachineTemplate != nil {
		currentInfraMachineTemplateRef = &currentMachineDeployment.object.Spec.Template.Spec.InfrastructureRef
	}
	desiredMachineDeployment.infrastructureMachineTemplate = templateToTemplate(templateToInput{
		template:              machineDeploymentClass.infrastructureMachineTemplate,
		templateClonedFromRef: objToRef(machineDeploymentClass.infrastructureMachineTemplate),
		cluster:               current.cluster,
		namePrefix:            infrastructureMachineTemplateNamePrefix(current.cluster.Name, machineDeploymentTopology.Name),
		currentObjectRef:      currentInfraMachineTemplateRef,
		labels:                mergeMap(machineDeploymentTopology.Metadata.Labels, machineDeploymentClass.metadata.Labels),
		annotations:           mergeMap(machineDeploymentTopology.Metadata.Annotations, machineDeploymentClass.metadata.Annotations),
	})

	gv := clusterv1.GroupVersion
	desiredMachineDeploymentObj := &clusterv1.MachineDeployment{
		TypeMeta: metav1.TypeMeta{
			Kind:       gv.WithKind("MachineDeployment").Kind,
			APIVersion: gv.String(),
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      names.SimpleNameGenerator.GenerateName(fmt.Sprintf("%s-%s-", current.cluster.Name, machineDeploymentTopology.Name)),
			Namespace: current.cluster.Namespace,
		},
		Spec: clusterv1.MachineDeploymentSpec{
			ClusterName: current.cluster.Name,
			Template: clusterv1.MachineTemplateSpec{
				Spec: clusterv1.MachineSpec{
					ClusterName:       current.cluster.Name,
					Version:           pointer.String(current.cluster.Spec.Topology.Version),
					Bootstrap:         clusterv1.Bootstrap{ConfigRef: objToRef(desiredMachineDeployment.bootstrapTemplate)},
					InfrastructureRef: *objToRef(desiredMachineDeployment.infrastructureMachineTemplate),
				},
			},
		},
	}

	// If an existing MachineDeployment is present, override the MachineDeployment
	// object with the same name.
	if currentMachineDeployment != nil && currentMachineDeployment.object != nil {
		desiredMachineDeploymentObj.SetName(currentMachineDeployment.object.Name)
	}

	labels := mergeMap(machineDeploymentTopology.Metadata.Labels, machineDeploymentClass.metadata.Labels)
	labels[clusterv1.ClusterLabelName] = current.cluster.Name
	labels[clusterv1.ClusterTopologyLabelName] = ""
	labels[clusterv1.ClusterTopologyMachineDeploymentLabelName] = machineDeploymentTopology.Name
	desiredMachineDeploymentObj.SetLabels(labels)

	desiredMachineDeploymentObj.Annotations = mergeMap(machineDeploymentTopology.Metadata.Annotations, machineDeploymentClass.metadata.Annotations)

	if machineDeploymentTopology.Replicas != nil {
		desiredMachineDeploymentObj.Spec.Replicas = pointer.Int32(int32(*machineDeploymentTopology.Replicas))
	}

	desiredMachineDeployment.object = desiredMachineDeploymentObj
	return desiredMachineDeployment, nil
}

type templateToInput struct {
	template              *unstructured.Unstructured
	templateClonedFromRef *corev1.ObjectReference
	cluster               *clusterv1.Cluster
	namePrefix            string
	currentObjectRef      *corev1.ObjectReference
	labels                map[string]string
	annotations           map[string]string
}

// templateToObject generates an object from a template, taking care
// of adding required labels (cluster, topology), annotations (clonedFrom)
// and assigning a meaningful name (or reusing current reference name).
func templateToObject(in templateToInput) (*unstructured.Unstructured, error) {
	// Enforce the topology labels into the provided label set.
	// NOTE: The cluster label is added at creation time so this object could be read by the ClusterTopology
	// controller immediately after creation, even before other controllers are going to add the label (if missing).
	labels := in.labels
	if labels == nil {
		labels = map[string]string{}
	}
	labels[clusterv1.ClusterLabelName] = in.cluster.Name
	labels[clusterv1.ClusterTopologyLabelName] = ""

	// Generate the object from the template.
	// NOTE: OwnerRef can't be set at this stage; other controllers are going to add OwnerReferences when
	// the object is actually created.
	object, err := external.GenerateTemplate(&external.GenerateTemplateInput{
		Template:    in.template,
		TemplateRef: in.templateClonedFromRef,
		Namespace:   in.cluster.Namespace,
		Labels:      labels,
		Annotations: in.annotations,
		ClusterName: in.cluster.Name,
	})
	if err != nil {
		return nil, err
	}

	// Ensure the generated objects have a meaningful name.
	// NOTE: In case there is already a ref to this object in the Cluster, re-use the same name
	// in order to simplify compare at later stages of the reconcile process.
	object.SetName(names.SimpleNameGenerator.GenerateName(in.namePrefix))
	if in.currentObjectRef != nil && len(in.currentObjectRef.Name) > 0 {
		object.SetName(in.currentObjectRef.Name)
	}

	return object, nil
}

// templateToTemplate generates a template from an existing template, taking care
// of adding required labels (cluster, topology), annotations (clonedFrom)
// and assigning a meaningful name (or reusing current reference name).
// NOTE: We are creating a copy of the ClusterClass template for each cluster so
// it is possible to add cluster specific information without affecting the original object.
func templateToTemplate(in templateToInput) *unstructured.Unstructured {
	template := &unstructured.Unstructured{}
	in.template.DeepCopyInto(template)

	// Remove all the info automatically assigned by the API server and not relevant from
	// the copy of the template.
	template.SetResourceVersion("")
	template.SetFinalizers(nil)
	template.SetUID("")
	template.SetSelfLink("")

	// Enforce the topology labels into the provided label set.
	// NOTE: The cluster label is added at creation time so this object could be read by the ClusterTopology
	// controller immediately after creation, even before other controllers are going to add the label (if missing).
	labels := template.GetLabels()
	if labels == nil {
		labels = map[string]string{}
	}
	for key, value := range in.labels {
		labels[key] = value
	}
	labels[clusterv1.ClusterLabelName] = in.cluster.Name
	labels[clusterv1.ClusterTopologyLabelName] = ""
	template.SetLabels(labels)

	// Enforce cloned from annotations.
	annotations := template.GetAnnotations()
	if annotations == nil {
		annotations = map[string]string{}
	}
	for key, value := range in.annotations {
		annotations[key] = value
	}
	annotations[clusterv1.TemplateClonedFromNameAnnotation] = in.templateClonedFromRef.Name
	annotations[clusterv1.TemplateClonedFromGroupKindAnnotation] = in.templateClonedFromRef.GroupVersionKind().GroupKind().String()
	template.SetAnnotations(annotations)

	// Ensure the generated template gets a meaningful name.
	// NOTE: In case there is already an object ref to this template, it is required to re-use the same name
	// in order to simplify compare at later stages of the reconcile process.
	template.SetName(names.SimpleNameGenerator.GenerateName(in.namePrefix))
	if in.currentObjectRef != nil && len(in.currentObjectRef.Name) > 0 {
		template.SetName(in.currentObjectRef.Name)
	}

	return template
}

// mergeMap merges two maps into another one.
// NOTE: In case a key exists in both maps, the value in the first map is preserved.
func mergeMap(a, b map[string]string) map[string]string {
	m := make(map[string]string)
	for k, v := range b {
		m[k] = v
	}
	for k, v := range a {
		m[k] = v
	}
	return m
}
